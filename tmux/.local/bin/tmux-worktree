#!/usr/bin/env bun
/**
 * tmux-worktree: åˆ›å»º git worktree å¹¶åœ¨æ–° tmux session ä¸­æ‰“å¼€ï¼Œè‡ªåŠ¨è¿è¡Œ Claude Code
 *
 * ç”¨æ³•:
 *   tmux-worktree <branch>              # åŸºäºç°æœ‰åˆ†æ”¯åˆ›å»º worktree
 *   tmux-worktree -b <branch>           # åˆ›å»ºæ–°åˆ†æ”¯çš„ worktree
 *   tmux-worktree <branch> --no-claude  # ä¸è‡ªåŠ¨è¿è¡Œ cl
 *   tmux-worktree finish                # åˆå¹¶å›ä¸»åˆ†æ”¯å¹¶æ¸…ç†
 */

import { $ } from "bun";
import { parseArgs } from "util";

$.throws(false);

// ===== å·¥å…·å‡½æ•° =====

async function run(cmd: string[]): Promise<{ ok: boolean; stdout: string }> {
  const proc = Bun.spawn(cmd, { stdout: "pipe", stderr: "inherit" });
  const stdout = await new Response(proc.stdout).text();
  const exitCode = await proc.exited;
  return { ok: exitCode === 0, stdout: stdout.trim() };
}

async function runCheck(cmd: string[]): Promise<string> {
  const { ok, stdout } = await run(cmd);
  if (!ok) {
    console.error(`å‘½ä»¤å¤±è´¥: ${cmd.join(" ")}`);
    process.exit(1);
  }
  return stdout;
}

// ===== Git å‡½æ•° =====

async function getProjectRoot(): Promise<string> {
  return runCheck(["git", "rev-parse", "--show-toplevel"]);
}

async function getProjectName(): Promise<string> {
  const root = await getProjectRoot();
  return root.split("/").pop()!;
}

async function getMainBranch(): Promise<string> {
  const { ok, stdout } = await run([
    "git",
    "symbolic-ref",
    "refs/remotes/origin/HEAD",
  ]);
  if (ok) {
    return stdout.split("/").pop()!;
  }

  // å›é€€: æ£€æŸ¥ main æˆ– master
  for (const branch of ["main", "master"]) {
    const { ok } = await run([
      "git",
      "show-ref",
      "--verify",
      `refs/heads/${branch}`,
    ]);
    if (ok) return branch;
  }
  return "main";
}

async function getCurrentBranch(): Promise<string> {
  return runCheck(["git", "rev-parse", "--abbrev-ref", "HEAD"]);
}

async function getWorktreePath(project: string, branch: string): Promise<string> {
  const root = await getProjectRoot();
  const parent = root.split("/").slice(0, -1).join("/");
  const safeBranch = branch.replace(/\//g, "-");
  return `${parent}/worktrees/${project}-${safeBranch}`;
}

async function getMainRepoPath(): Promise<string> {
  const { stdout } = await run(["git", "worktree", "list", "--porcelain"]);
  const lines = stdout.split("\n");
  for (const line of lines) {
    if (line.startsWith("worktree ")) {
      return line.slice(9);
    }
  }
  return getProjectRoot();
}

async function isWorktree(): Promise<boolean> {
  const gitDir = await runCheck(["git", "rev-parse", "--git-dir"]);
  return gitDir.includes(".git/worktrees");
}

async function worktreeExists(path: string): Promise<boolean> {
  const file = Bun.file(path);
  return file.exists();
}

// ===== Tmux å‡½æ•° =====

async function sessionExists(name: string): Promise<boolean> {
  const { ok } = await run(["tmux", "has-session", "-t", name]);
  return ok;
}

function getCurrentSession(): string | null {
  if (!process.env.TMUX) return null;
  const result = Bun.spawnSync(["tmux", "display-message", "-p", "#S"]);
  if (result.exitCode === 0) {
    return new TextDecoder().decode(result.stdout).trim();
  }
  return null;
}

// ===== å‘½ä»¤ =====

async function cmdCreate(branch: string, newBranch: boolean, noClaude: boolean) {
  // æ£€æŸ¥æ˜¯å¦åœ¨ git ä»“åº“ä¸­
  const { ok } = await run(["git", "rev-parse", "--git-dir"]);
  if (!ok) {
    console.error("é”™è¯¯: ä¸åœ¨ git ä»“åº“ä¸­");
    process.exit(1);
  }

  const project = await getProjectName();
  const wtPath = await getWorktreePath(project, branch);
  const safeBranch = branch.replace(/\//g, "-");
  const sessionName = `${project}-${safeBranch}`;

  // åˆ›å»ºæˆ–ä½¿ç”¨ç°æœ‰ worktree
  if (!(await worktreeExists(wtPath))) {
    const parentDir = wtPath.split("/").slice(0, -1).join("/");
    await $`mkdir -p ${parentDir}`;

    let result;
    if (newBranch) {
      result = await $`git worktree add -b ${branch} ${wtPath}`;
    } else {
      result = await $`git worktree add ${wtPath} ${branch}`;
    }

    if (result.exitCode !== 0) {
      console.error(`é”™è¯¯: æ— æ³•åˆ›å»º worktree`);
      process.exit(1);
    }
    console.log(`âœ“ Worktree å·²åˆ›å»º: ${wtPath}`);
  } else {
    console.log(`âœ“ Worktree å·²å­˜åœ¨: ${wtPath}`);
  }

  // åˆ›å»º tmux session
  if (await sessionExists(sessionName)) {
    console.log(`Session '${sessionName}' å·²å­˜åœ¨ï¼Œæ­£åœ¨é™„åŠ ...`);
    await $`tmux attach-session -t ${sessionName}`;
    return;
  }

  await $`tmux new-session -d -s ${sessionName} -c ${wtPath}`;
  await $`tmux split-window -h -t ${sessionName} -c ${wtPath}`;

  if (!noClaude) {
    await $`tmux select-pane -t ${sessionName} -L`;
    await $`tmux send-keys -t ${sessionName} "cd ${wtPath} && cl" C-m`;
    await $`tmux select-pane -t ${sessionName} -R`;
    await $`tmux send-keys -t ${sessionName} "cd ${wtPath} && cl" C-m`;
    await $`tmux select-pane -t ${sessionName} -L`;
  }

  await $`tmux attach-session -t ${sessionName}`;
}

async function cmdFinish() {
  // æ£€æŸ¥æ˜¯å¦åœ¨ worktree ä¸­
  if (!(await isWorktree())) {
    console.error("é”™è¯¯: ä¸åœ¨ worktree ä¸­ï¼Œè¯·åœ¨ worktree ç›®å½•ä¸­è¿è¡Œæ­¤å‘½ä»¤");
    process.exit(1);
  }

  const currentBranch = await getCurrentBranch();
  const mainBranch = await getMainBranch();
  const mainRepo = await getMainRepoPath();
  const currentPath = process.cwd();
  const sessionName = getCurrentSession();

  console.log(`åˆ†æ”¯: ${currentBranch}`);
  console.log(`ä¸»åˆ†æ”¯: ${mainBranch}`);
  console.log(`ä¸»ä»“åº“: ${mainRepo}`);
  console.log();

  // æ£€æŸ¥æ˜¯å¦æœ‰æœªæäº¤çš„æ›´æ”¹
  const { stdout: status } = await run(["git", "status", "--porcelain"]);
  if (status) {
    console.error("é”™è¯¯: æœ‰æœªæäº¤çš„æ›´æ”¹ï¼Œè¯·å…ˆæäº¤æˆ– stash");
    console.log(status);
    process.exit(1);
  }

  // åˆ‡æ¢åˆ°ä¸»ä»“åº“å¹¶åˆå¹¶
  process.chdir(mainRepo);

  console.log(`æ­£åœ¨åˆ‡æ¢åˆ° ${mainBranch}...`);
  await runCheck(["git", "checkout", mainBranch]);

  console.log(`æ­£åœ¨æ‹‰å–æœ€æ–°ä»£ç ...`);
  await run(["git", "pull"]);

  console.log(`æ­£åœ¨åˆå¹¶ ${currentBranch}...`);
  const { ok: mergeOk } = await run([
    "git",
    "merge",
    currentBranch,
    "-m",
    `Merge branch '${currentBranch}'`,
  ]);

  if (!mergeOk) {
    console.error("é”™è¯¯: åˆå¹¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨è§£å†³å†²çª");
    process.exit(1);
  }

  console.log(`âœ“ å·²åˆå¹¶ ${currentBranch} åˆ° ${mainBranch}`);

  // åˆ é™¤ worktree
  console.log(`æ­£åœ¨åˆ é™¤ worktree...`);
  await $`git worktree remove ${currentPath} --force`;
  console.log(`âœ“ Worktree å·²åˆ é™¤`);

  // åˆ é™¤åˆ†æ”¯
  console.log(`æ­£åœ¨åˆ é™¤åˆ†æ”¯ ${currentBranch}...`);
  await $`git branch -d ${currentBranch}`;
  console.log(`âœ“ åˆ†æ”¯å·²åˆ é™¤`);

  // å…³é—­ tmux session
  if (sessionName) {
    console.log(`æ­£åœ¨å…³é—­ session ${sessionName}...`);
    await run(["tmux", "kill-session", "-t", sessionName]);
    console.log(`âœ“ Session å·²å…³é—­`);
  }

  console.log();
  console.log("ğŸ‰ å®Œæˆï¼å·²åˆå¹¶å¹¶æ¸…ç†");
}

// ===== Main =====

const { values, positionals } = parseArgs({
  args: Bun.argv.slice(2),
  options: {
    "new-branch": { type: "boolean", short: "b", default: false },
    "no-claude": { type: "boolean", default: false },
    help: { type: "boolean", short: "h", default: false },
  },
  allowPositionals: true,
});

if (values.help) {
  console.log(`
tmux-worktree: åˆ›å»º git worktree å¹¶åœ¨æ–° tmux session ä¸­æ‰“å¼€

ç”¨æ³•:
  tmux-worktree <branch>              åŸºäºç°æœ‰åˆ†æ”¯åˆ›å»º worktree
  tmux-worktree -b <branch>           åˆ›å»ºæ–°åˆ†æ”¯çš„ worktree
  tmux-worktree <branch> --no-claude  ä¸è‡ªåŠ¨è¿è¡Œ Claude Code
  tmux-worktree finish                åˆå¹¶å›ä¸»åˆ†æ”¯å¹¶æ¸…ç†
`);
  process.exit(0);
}

const command = positionals[0];

if (command === "finish") {
  await cmdFinish();
} else if (command) {
  await cmdCreate(command, values["new-branch"]!, values["no-claude"]!);
} else {
  console.error("ç”¨æ³•: tmux-worktree <branch> æˆ– tmux-worktree finish");
  process.exit(1);
}
